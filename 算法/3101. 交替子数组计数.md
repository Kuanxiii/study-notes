# [3101. 交替子数组计数](https://leetcode.cn/problems/count-alternating-subarrays/description/)

## 说明

```
给你一个二进制数组nums 。

如果一个子数组中 不存在 两个 相邻 元素的值 相同 的情况，我们称这样的子数组为 交替子数组 。

返回数组 nums 中交替子数组的数量。

 

示例 1：

输入： nums = [0,1,1,1]

输出： 5

解释：

以下子数组是交替子数组：[0] 、[1] 、[1] 、[1] 以及 [0,1] 。

示例 2：

输入： nums = [1,0,1,0]

输出： 10

解释：

数组的每个子数组都是交替子数组。可以统计在内的子数组共有 10 个。

 

提示：

1 <= nums.length <= 105
nums[i] 不是 0 就是 1 。
```

## 题解思路

### 动态规划思想

- 利用动态规划的思想，把问题拆解开
- 用一个指针进行遍历，判断以该元素结尾的交替子数组有多少个
- 如果当前元素和前一个元素不相同，那么以当前元素结尾的交替子数组，应该是前一个结尾的子数组数+1
- 如果当前元素和前一个元素相同。那么以当前元素结尾的交替子数组只有它本身这一个
- 维护一个count，用以记录前一个元素结尾的交替子数组有多少个
- 遍历完成后，累加的值即为全部的交替子数组
- 以`nums[i]`结尾的交替子数组数的状态转移方程：
  - count[i] = nums[i] != nums[i-1] ? count[i-1] + 1 : 1
- 复杂问题简单化
- 时间复杂度: O(n)
- 空间复杂度: O(1)



## Code

### 动态规划思想

```java
class Solution {
    public long countAlternatingSubarrays(int[] nums) {
        // 用一个指针进行遍历，判断以该元素结尾的交替子数组有多少个
        // 如果当前元素和前一个元素相同。那么以当前元素结尾的交替子数组只有它本身这一个
        // 如果当前元素和前一个元素不相同，那么以当前元素结尾的交替子数组，应该是前一个结尾的子数组数+1
        // 遍历完成后，累加的值即为全部的交替子数组
        // 维护一个count，用以记录前一个元素结尾的交替子数组有多少个
        long count = 0;
        // 结果是long.....
        long res = 0;
        for(int i = 0; i < nums.length; i++){
            if(i >= 1 && nums[i] != nums[i-1]){
                // 如果当前元素和前一个元素不相同，那么以当前元素结尾的交替子数组，应该是前一个结尾的子数组数+1
                count++;
            }else{
                // 如果当前元素和前一个元素相同。那么以当前元素结尾的交替子数组只有它本身这一个
                count = 1;
            }
            res += count;
        }
        return res;
    }
}
```

